{"/home/travis/build/npmtest/node-npmtest-imap/test.js":"/* istanbul instrument in package npmtest_imap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-imap/lib.npmtest_imap.js":"/* istanbul instrument in package npmtest_imap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_imap = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_imap = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-imap/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-imap && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_imap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_imap\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_imap.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_imap.rollup.js'] =\n            local.assetsDict['/assets.npmtest_imap.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_imap.__dirname +\n                    '/lib.npmtest_imap.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-imap/imap/lib/Connection.js":"var tls = require('tls'),\n    Socket = require('net').Socket,\n    EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    inspect = require('util').inspect,\n    isDate = require('util').isDate,\n    utf7 = require('utf7').imap;\n\nvar Parser = require('./Parser').Parser,\n    parseExpr = require('./Parser').parseExpr,\n    parseHeader = require('./Parser').parseHeader;\n\nvar MAX_INT = 9007199254740992,\n    KEEPALIVE_INTERVAL = 10000,\n    MAX_IDLE_WAIT = 300000, // 5 minutes\n    MONTHS = ['Jan', 'Feb', 'Mar',\n              'Apr', 'May', 'Jun',\n              'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'],\n    FETCH_ATTR_MAP = {\n      'RFC822.SIZE': 'size',\n      'BODY': 'struct',\n      'BODYSTRUCTURE': 'struct',\n      'ENVELOPE': 'envelope',\n      'INTERNALDATE': 'date'\n    },\n    SPECIAL_USE_ATTRIBUTES = [\n      '\\\\All',\n      '\\\\Archive',\n      '\\\\Drafts',\n      '\\\\Flagged',\n      '\\\\Important',\n      '\\\\Junk',\n      '\\\\Sent',\n      '\\\\Trash'\n    ],\n    CRLF = '\\r\\n',\n    RE_CMD = /^([^ ]+)(?: |$)/,\n    RE_UIDCMD_HASRESULTS = /^UID (?:FETCH|SEARCH|SORT)/,\n    RE_IDLENOOPRES = /^(IDLE|NOOP) /,\n    RE_OPENBOX = /^EXAMINE|SELECT$/,\n    RE_BODYPART = /^BODY\\[/,\n    RE_INVALID_KW_CHARS = /[\\(\\)\\{\\\\\\\"\\]\\%\\*\\x00-\\x20\\x7F]/,\n    RE_NUM_RANGE = /^(?:[\\d]+|\\*):(?:[\\d]+|\\*)$/,\n    RE_BACKSLASH = /\\\\/g,\n    RE_DBLQUOTE = /\"/g,\n    RE_ESCAPE = /\\\\\\\\/g,\n    RE_INTEGER = /^\\d+$/;\n\nfunction Connection(config) {\n  if (!(this instanceof Connection))\n    return new Connection(config);\n\n  EventEmitter.call(this);\n\n  config || (config = {});\n\n  this._config = {\n    localAddress: config.localAddress,\n    socket: config.socket,\n    socketTimeout: config.socketTimeout || 0,\n    host: config.host || 'localhost',\n    port: config.port || 143,\n    tls: config.tls,\n    tlsOptions: config.tlsOptions,\n    autotls: config.autotls,\n    user: config.user,\n    password: config.password,\n    xoauth: config.xoauth,\n    xoauth2: config.xoauth2,\n    connTimeout: config.connTimeout || 10000,\n    authTimeout: config.authTimeout || 5000,\n    keepalive: (config.keepalive === undefined || config.keepalive === null\n                ? true\n                : config.keepalive)\n  };\n\n  this._sock = config.socket || undefined;\n  this._tagcount = 0;\n  this._tmrConn = undefined;\n  this._tmrKeepalive = undefined;\n  this._tmrAuth = undefined;\n  this._queue = [];\n  this._box = undefined;\n  this._idle = { started: undefined, enabled: false };\n  this._parser = undefined;\n  this._curReq = undefined;\n  this.delimiter = undefined;\n  this.namespaces = undefined;\n  this.state = 'disconnected';\n  this.debug = config.debug;\n}\ninherits(Connection, EventEmitter);\n\nConnection.prototype.connect = function() {\n  var config = this._config,\n      self = this,\n      socket,\n      parser,\n      tlsOptions;\n\n  socket = config.socket || new Socket();\n  socket.setKeepAlive(true);\n  this._sock = undefined;\n  this._tagcount = 0;\n  this._tmrConn = undefined;\n  this._tmrKeepalive = undefined;\n  this._tmrAuth = undefined;\n  this._queue = [];\n  this._box = undefined;\n  this._idle = { started: undefined, enabled: false };\n  this._parser = undefined;\n  this._curReq = undefined;\n  this.delimiter = undefined;\n  this.namespaces = undefined;\n  this.state = 'disconnected';\n\n  if (config.tls) {\n    tlsOptions = {};\n    tlsOptions.host = config.host;\n    // Host name may be overridden the tlsOptions\n    for (var k in config.tlsOptions)\n      tlsOptions[k] = config.tlsOptions[k];\n    tlsOptions.socket = socket;\n  }\n\n  if (config.tls)\n    this._sock = tls.connect(tlsOptions, onconnect);\n  else {\n    socket.once('connect', onconnect);\n    this._sock = socket;\n  }\n\n  function onconnect() {\n    clearTimeout(self._tmrConn);\n    self.state = 'connected';\n    self.debug && self.debug('[connection] Connected to host');\n    self._tmrAuth = setTimeout(function() {\n      var err = new Error('Timed out while authenticating with server');\n      err.source = 'timeout-auth';\n      self.emit('error', err);\n      socket.destroy();\n    }, config.authTimeout);\n  }\n\n  this._onError = function(err) {\n    clearTimeout(self._tmrConn);\n    clearTimeout(self._tmrAuth);\n    self.debug && self.debug('[connection] Error: ' + err);\n    err.source = 'socket';\n    self.emit('error', err);\n  };\n  this._sock.on('error', this._onError);\n\n  this._onSocketTimeout = function() {\n    clearTimeout(self._tmrConn);\n    clearTimeout(self._tmrAuth);\n    clearTimeout(self._tmrKeepalive);\n    self.state = 'disconnected';\n    self.debug && self.debug('[connection] Socket timeout');\n\n    var err = new Error('Socket timed out while talking to server');\n    err.source = 'socket-timeout';\n    self.emit('error', err);\n    socket.destroy();\n  };\n  this._sock.on('timeout', this._onSocketTimeout);\n  socket.setTimeout(config.socketTimeout);\n\n  socket.once('close', function(had_err) {\n    clearTimeout(self._tmrConn);\n    clearTimeout(self._tmrAuth);\n    clearTimeout(self._tmrKeepalive);\n    self.state = 'disconnected';\n    self.debug && self.debug('[connection] Closed');\n    self.emit('close', had_err);\n  });\n\n  socket.once('end', function() {\n    clearTimeout(self._tmrConn);\n    clearTimeout(self._tmrAuth);\n    clearTimeout(self._tmrKeepalive);\n    self.state = 'disconnected';\n    self.debug && self.debug('[connection] Ended');\n    self.emit('end');\n  });\n\n  this._parser = parser = new Parser(this._sock, this.debug);\n\n  parser.on('untagged', function(info) {\n    self._resUntagged(info);\n  });\n  parser.on('tagged', function(info) {\n    self._resTagged(info);\n  });\n  parser.on('body', function(stream, info) {\n    var msg = self._curReq.fetchCache[info.seqno], toget;\n\n    if (msg === undefined) {\n      msg = self._curReq.fetchCache[info.seqno] = {\n        msgEmitter: new EventEmitter(),\n        toget: self._curReq.fetching.slice(0),\n        attrs: {},\n        ended: false\n      };\n\n      self._curReq.bodyEmitter.emit('message', msg.msgEmitter, info.seqno);\n    }\n\n    toget = msg.toget;\n\n    // here we compare the parsed version of the expression inside BODY[]\n    // because 'HEADER.FIELDS (TO FROM)' really is equivalent to\n    // 'HEADER.FIELDS (\"TO\" \"FROM\")' and some servers will actually send the\n    // quoted form even if the client did not use quotes\n    var thisbody = parseExpr(info.which);\n    for (var i = 0, len = toget.length; i < len; ++i) {\n      if (_deepEqual(thisbody, toget[i])) {\n        toget.splice(i, 1);\n        msg.msgEmitter.emit('body', stream, info);\n        return;\n      }\n    }\n    stream.resume(); // a body we didn't ask for?\n  });\n  parser.on('continue', function(info) {\n    var type = self._curReq.type;\n    if (type === 'IDLE') {\n      if (self._queue.length\n          && self._idle.started === 0\n          && self._curReq\n          && self._curReq.type === 'IDLE'\n          && self._sock\n          && self._sock.writable\n          && !self._idle.enabled) {\n        self.debug && self.debug('=> DONE');\n        self._sock.write('DONE' + CRLF);\n        return;\n      }\n      // now idling\n      self._idle.started = Date.now();\n    } else if (/^AUTHENTICATE XOAUTH/.test(self._curReq.fullcmd)) {\n      self._curReq.oauthError = new Buffer(info.text, 'base64').toString('utf8');\n      self.debug && self.debug('=> ' + inspect(CRLF));\n      self._sock.write(CRLF);\n    } else if (type === 'APPEND') {\n      self._sockWriteAppendData(self._curReq.appendData);\n    } else if (self._curReq.lines && self._curReq.lines.length) {\n      var line = self._curReq.lines.shift() + '\\r\\n';\n      self.debug && self.debug('=> ' + inspect(line));\n      self._sock.write(line, 'binary');\n    }\n  });\n  parser.on('other', function(line) {\n    var m;\n    if (m = RE_IDLENOOPRES.exec(line)) {\n      // no longer idling\n      self._idle.enabled = false;\n      self._idle.started = undefined;\n      clearTimeout(self._tmrKeepalive);\n\n      self._curReq = undefined;\n\n      if (self._queue.length === 0\n          && self._config.keepalive\n          && self.state === 'authenticated'\n          && !self._idle.enabled) {\n        self._idle.enabled = true;\n        if (m[1] === 'NOOP')\n          self._doKeepaliveTimer();\n        else\n          self._doKeepaliveTimer(true);\n      }\n\n      self._processQueue();\n    }\n  });\n\n  this._tmrConn = setTimeout(function() {\n    var err = new Error('Timed out while connecting to server');\n    err.source = 'timeout';\n    self.emit('error', err);\n    socket.destroy();\n  }, config.connTimeout);\n\n  socket.connect({\n    port: config.port,\n    host: config.host,\n    localAddress: config.localAddress\n  });\n};\n\nConnection.prototype.serverSupports = function(cap) {\n  return (this._caps && this._caps.indexOf(cap) > -1);\n};\n\nConnection.prototype.destroy = function() {\n  this._queue = [];\n  this._curReq = undefined;\n  this._sock && this._sock.end();\n};\n\nConnection.prototype.end = function() {\n  var self = this;\n  this._enqueue('LOGOUT', function() {\n    self._queue = [];\n    self._curReq = undefined;\n    self._sock.end();\n  });\n};\n\nConnection.prototype.append = function(data, options, cb) {\n  var literal = this.serverSupports('LITERAL+');\n  if (typeof options === 'function') {\n    cb = options;\n    options = undefined;\n  }\n  options = options || {};\n  if (!options.mailbox) {\n    if (!this._box)\n      throw new Error('No mailbox specified or currently selected');\n    else\n      options.mailbox = this._box.name;\n  }\n  var cmd = 'APPEND \"' + escape(utf7.encode(''+options.mailbox)) + '\"';\n  if (options.flags) {\n    if (!Array.isArray(options.flags))\n      options.flags = [options.flags];\n    if (options.flags.length > 0) {\n      for (var i = 0, len = options.flags.length; i < len; ++i) {\n        if (options.flags[i][0] !== '$' && options.flags[i][0] !== '\\\\')\n          options.flags[i] = '\\\\' + options.flags[i];\n      }\n      cmd += ' (' + options.flags.join(' ') + ')';\n    }\n  }\n  if (options.date) {\n    if (!isDate(options.date))\n      throw new Error('`date` is not a Date object');\n    cmd += ' \"';\n    cmd += options.date.getDate();\n    cmd += '-';\n    cmd += MONTHS[options.date.getMonth()];\n    cmd += '-';\n    cmd += options.date.getFullYear();\n    cmd += ' ';\n    cmd += ('0' + options.date.getHours()).slice(-2);\n    cmd += ':';\n    cmd += ('0' + options.date.getMinutes()).slice(-2);\n    cmd += ':';\n    cmd += ('0' + options.date.getSeconds()).slice(-2);\n    cmd += ((options.date.getTimezoneOffset() > 0) ? ' -' : ' +' );\n    cmd += ('0' + (-options.date.getTimezoneOffset() / 60)).slice(-2);\n    cmd += ('0' + (-options.date.getTimezoneOffset() % 60)).slice(-2);\n    cmd += '\"';\n  }\n  cmd += ' {';\n  cmd += (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));\n  cmd += (literal ? '+' : '') + '}';\n\n  this._enqueue(cmd, cb);\n\n  if (literal)\n    this._queue[this._queue.length - 1].literalAppendData = data;\n  else\n    this._queue[this._queue.length - 1].appendData = data;\n};\n\nConnection.prototype.getSpecialUseBoxes = function(cb) {\n  this._enqueue('XLIST \"\" \"*\"', cb);\n};\n\nConnection.prototype.getBoxes = function(namespace, cb) {\n  if (typeof namespace === 'function') {\n    cb = namespace;\n    namespace = '';\n  }\n\n  namespace = escape(utf7.encode(''+namespace));\n\n  this._enqueue('LIST \"' + namespace + '\" \"*\"', cb);\n};\n\nConnection.prototype.id = function(identification, cb) {\n  if (!this.serverSupports('ID'))\n    throw new Error('Server does not support ID');\n  var cmd = 'ID';\n  if ((identification === null) || (Object.keys(identification).length === 0))\n    cmd += ' NIL';\n  else {\n    if (Object.keys(identification).length > 30)\n      throw new Error('Max allowed number of keys is 30');\n    var kv = [];\n    for (var k in identification) {\n      if (Buffer.byteLength(k) > 30)\n        throw new Error('Max allowed key length is 30');\n      if (Buffer.byteLength(identification[k]) > 1024)\n        throw new Error('Max allowed value length is 1024');\n      kv.push('\"' + escape(k) + '\"');\n      kv.push('\"' + escape(identification[k]) + '\"');\n    }\n    cmd += ' (' + kv.join(' ') + ')';\n  }\n  this._enqueue(cmd, cb);\n};\n\nConnection.prototype.openBox = function(name, readOnly, cb) {\n  if (this.state !== 'authenticated')\n    throw new Error('Not authenticated');\n\n  if (typeof readOnly === 'function') {\n    cb = readOnly;\n    readOnly = false;\n  }\n\n  name = ''+name;\n  var encname = escape(utf7.encode(name)),\n      cmd = (readOnly ? 'EXAMINE' : 'SELECT'),\n      self = this;\n\n  cmd += ' \"' + encname + '\"';\n\n  if (this.serverSupports('CONDSTORE'))\n    cmd += ' (CONDSTORE)';\n\n  this._enqueue(cmd, function(err) {\n    if (err) {\n      self._box = undefined;\n      cb(err);\n    } else {\n      self._box.name = name;\n      cb(err, self._box);\n    }\n  });\n};\n\nConnection.prototype.closeBox = function(shouldExpunge, cb) {\n  if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n\n  var self = this;\n\n  if (typeof shouldExpunge === 'function') {\n    cb = shouldExpunge;\n    shouldExpunge = true;\n  }\n\n  if (shouldExpunge) {\n    this._enqueue('CLOSE', function(err) {\n      if (!err)\n        self._box = undefined;\n\n      cb(err);\n    });\n  } else {\n    if (this.serverSupports('UNSELECT')) {\n      // use UNSELECT if available, as it claims to be \"cleaner\" than the\n      // alternative \"hack\"\n      this._enqueue('UNSELECT', function(err) {\n        if (!err)\n          self._box = undefined;\n\n        cb(err);\n      });\n    } else {\n      // \"HACK\": close the box without expunging by attempting to SELECT a\n      // non-existent mailbox\n      var badbox = 'NODEJSIMAPCLOSINGBOX' + Date.now();\n      this._enqueue('SELECT \"' + badbox + '\"', function(err) {\n        self._box = undefined;\n        cb();\n      });\n    }\n  }\n};\n\nConnection.prototype.addBox = function(name, cb) {\n  this._enqueue('CREATE \"' + escape(utf7.encode(''+name)) + '\"', cb);\n};\n\nConnection.prototype.delBox = function(name, cb) {\n  this._enqueue('DELETE \"' + escape(utf7.encode(''+name)) + '\"', cb);\n};\n\nConnection.prototype.renameBox = function(oldname, newname, cb) {\n  var encoldname = escape(utf7.encode(''+oldname)),\n      encnewname = escape(utf7.encode(''+newname)),\n      self = this;\n\n  this._enqueue('RENAME \"' + encoldname + '\" \"' + encnewname + '\"',\n    function(err) {\n      if (err)\n        return cb(err);\n\n      if (self._box\n          && self._box.name === oldname\n          && oldname.toUpperCase() !== 'INBOX') {\n        self._box.name = newname;\n        cb(err, self._box);\n      } else\n        cb();\n    }\n  );\n};\n\nConnection.prototype.subscribeBox = function(name, cb) {\n\tthis._enqueue('SUBSCRIBE \"' + escape(utf7.encode(''+name)) + '\"', cb);\n};\n\nConnection.prototype.unsubscribeBox = function(name, cb) {\n\tthis._enqueue('UNSUBSCRIBE \"' + escape(utf7.encode(''+name)) + '\"', cb);\n};\n\nConnection.prototype.getSubscribedBoxes = function(namespace, cb) {\n\tif (typeof namespace === 'function') {\n\t\tcb = namespace;\n\t\tnamespace = '';\n\t}\n\n\tnamespace = escape(utf7.encode(''+namespace));\n\n\tthis._enqueue('LSUB \"' + namespace + '\" \"*\"', cb);\n};\n\nConnection.prototype.status = function(boxName, cb) {\n  if (this._box && this._box.name === boxName)\n    throw new Error('Cannot call status on currently selected mailbox');\n\n  boxName = escape(utf7.encode(''+boxName));\n\n  var info = [ 'MESSAGES', 'RECENT', 'UNSEEN', 'UIDVALIDITY', 'UIDNEXT' ];\n\n  if (this.serverSupports('CONDSTORE'))\n    info.push('HIGHESTMODSEQ');\n\n  info = info.join(' ');\n\n  this._enqueue('STATUS \"' + boxName + '\" (' + info + ')', cb);\n};\n\nConnection.prototype.expunge = function(uids, cb) {\n  if (typeof uids === 'function') {\n    cb = uids;\n    uids = undefined;\n  }\n\n  if (uids !== undefined) {\n    if (!Array.isArray(uids))\n      uids = [uids];\n    validateUIDList(uids);\n\n    if (uids.length === 0)\n      throw new Error('Empty uid list');\n\n    uids = uids.join(',');\n\n    if (!this.serverSupports('UIDPLUS'))\n      throw new Error('Server does not support this feature (UIDPLUS)');\n\n    this._enqueue('UID EXPUNGE ' + uids, cb);\n  } else\n    this._enqueue('EXPUNGE', cb);\n};\n\nConnection.prototype.search = function(criteria, cb) {\n  this._search('UID ', criteria, cb);\n};\n\nConnection.prototype._search = function(which, criteria, cb) {\n  if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n  else if (!Array.isArray(criteria))\n    throw new Error('Expected array for search criteria');\n\n  var cmd = which + 'SEARCH',\n      info = { hasUTF8: false /*output*/ },\n      query = buildSearchQuery(criteria, this._caps, info),\n      lines;\n  if (info.hasUTF8) {\n    cmd += ' CHARSET UTF-8';\n    lines = query.split(CRLF);\n    query = lines.shift();\n  }\n  cmd += query;\n  this._enqueue(cmd, cb);\n  if (info.hasUTF8) {\n    var req = this._queue[this._queue.length - 1];\n    req.lines = lines;\n  }\n};\n\nConnection.prototype.addFlags = function(uids, flags, cb) {\n  this._store('UID ', uids, { mode: '+', flags: flags }, cb);\n};\n\nConnection.prototype.delFlags = function(uids, flags, cb) {\n  this._store('UID ', uids, { mode: '-', flags: flags }, cb);\n};\n\nConnection.prototype.setFlags = function(uids, flags, cb) {\n  this._store('UID ', uids, { mode: '', flags: flags }, cb);\n};\n\nConnection.prototype.addKeywords = function(uids, keywords, cb) {\n  this._store('UID ', uids, { mode: '+', keywords: keywords }, cb);\n};\n\nConnection.prototype.delKeywords = function(uids, keywords, cb) {\n  this._store('UID ', uids, { mode: '-', keywords: keywords }, cb);\n};\n\nConnection.prototype.setKeywords = function(uids, keywords, cb) {\n  this._store('UID ', uids, { mode: '', keywords: keywords }, cb);\n};\n\nConnection.prototype._store = function(which, uids, cfg, cb) {\n  var mode = cfg.mode,\n      isFlags = (cfg.flags !== undefined),\n      items = (isFlags ? cfg.flags : cfg.keywords);\n  if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n  else if (uids === undefined)\n    throw new Error('No messages specified');\n\n  if (!Array.isArray(uids))\n    uids = [uids];\n  validateUIDList(uids);\n\n  if (uids.length === 0) {\n    throw new Error('Empty '\n                    + (which === '' ? 'sequence number' : 'uid')\n                    + 'list');\n  }\n\n  if ((!Array.isArray(items) && typeof items !== 'string')\n      || (Array.isArray(items) && items.length === 0))\n    throw new Error((isFlags ? 'Flags' : 'Keywords')\n                    + ' argument must be a string or a non-empty Array');\n  if (!Array.isArray(items))\n    items = [items];\n  for (var i = 0, len = items.length; i < len; ++i) {\n    if (isFlags) {\n      if (items[i][0] !== '\\\\')\n        items[i] = '\\\\' + items[i];\n    } else {\n      // keyword contains any char except control characters (%x00-1F and %x7F)\n      // and: '(', ')', '{', ' ', '%', '*', '\\', '\"', ']'\n      if (RE_INVALID_KW_CHARS.test(items[i])) {\n        throw new Error('The keyword \"' + items[i]\n                        + '\" contains invalid characters');\n      }\n    }\n  }\n\n  items = items.join(' ');\n  uids = uids.join(',');\n\n  var modifiers = '';\n  if (cfg.modseq !== undefined && !this._box.nomodseq)\n    modifiers += 'UNCHANGEDSINCE ' + cfg.modseq + ' ';\n\n  this._enqueue(which + 'STORE ' + uids + ' '\n                + modifiers\n                + mode + 'FLAGS.SILENT (' + items + ')', cb);\n};\n\nConnection.prototype.copy = function(uids, boxTo, cb) {\n  this._copy('UID ', uids, boxTo, cb);\n};\n\nConnection.prototype._copy = function(which, uids, boxTo, cb) {\n  if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n\n  if (!Array.isArray(uids))\n    uids = [uids];\n  validateUIDList(uids);\n\n  if (uids.length === 0) {\n    throw new Error('Empty '\n                    + (which === '' ? 'sequence number' : 'uid')\n                    + 'list');\n  }\n\n  boxTo = escape(utf7.encode(''+boxTo));\n\n  this._enqueue(which + 'COPY ' + uids.join(',') + ' \"' + boxTo + '\"', cb);\n};\n\nConnection.prototype.move = function(uids, boxTo, cb) {\n  this._move('UID ', uids, boxTo, cb);\n};\n\nConnection.prototype._move = function(which, uids, boxTo, cb) {\n  if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n\n  if (this.serverSupports('MOVE')) {\n    if (!Array.isArray(uids))\n      uids = [uids];\n    validateUIDList(uids);\n\n    if (uids.length === 0) {\n      throw new Error('Empty '\n                      + (which === '' ? 'sequence number' : 'uid')\n                      + 'list');\n    }\n\n    uids = uids.join(',');\n    boxTo = escape(utf7.encode(''+boxTo));\n\n    this._enqueue(which + 'MOVE ' + uids + ' \"' + boxTo + '\"', cb);\n  } else if (this._box.permFlags.indexOf('\\\\Deleted') === -1\n             && this._box.flags.indexOf('\\\\Deleted') === -1) {\n    throw new Error('Cannot move message: '\n                    + 'server does not allow deletion of messages');\n  } else {\n    var deletedUIDs, task = 0, self = this;\n    this._copy(which, uids, boxTo, function ccb(err, info) {\n      if (err)\n        return cb(err, info);\n\n      if (task === 0 && which && self.serverSupports('UIDPLUS')) {\n        // UIDPLUS gives us a 'UID EXPUNGE n' command to expunge a subset of\n        // messages with the \\Deleted flag set. This allows us to skip some\n        // actions.\n        task = 2;\n      }\n      // Make sure we don't expunge any messages marked as Deleted except the\n      // one we are moving\n      if (task === 0) {\n        self.search(['DELETED'], function(e, result) {\n          ++task;\n          deletedUIDs = result;\n          ccb(e, info);\n        });\n      } else if (task === 1) {\n        if (deletedUIDs.length) {\n          self.delFlags(deletedUIDs, '\\\\Deleted', function(e) {\n            ++task;\n            ccb(e, info);\n          });\n        } else {\n          ++task;\n          ccb(err, info);\n        }\n      } else if (task === 2) {\n        var cbMarkDel = function(e) {\n          ++task;\n          ccb(e, info);\n        };\n        if (which)\n          self.addFlags(uids, '\\\\Deleted', cbMarkDel);\n        else\n          self.seq.addFlags(uids, '\\\\Deleted', cbMarkDel);\n      } else if (task === 3) {\n        if (which && self.serverSupports('UIDPLUS')) {\n          self.expunge(uids, function(e) {\n            cb(e, info);\n          });\n        } else {\n          self.expunge(function(e) {\n            ++task;\n            ccb(e, info);\n          });\n        }\n      } else if (task === 4) {\n        if (deletedUIDs.length) {\n          self.addFlags(deletedUIDs, '\\\\Deleted', function(e) {\n            cb(e, info);\n          });\n        } else\n          cb(err, info);\n      }\n    });\n  }\n};\n\nConnection.prototype.fetch = function(uids, options) {\n  return this._fetch('UID ', uids, options);\n};\n\nConnection.prototype._fetch = function(which, uids, options) {\n  if (uids === undefined\n      || uids === null\n      || (Array.isArray(uids) && uids.length === 0))\n    throw new Error('Nothing to fetch');\n\n  if (!Array.isArray(uids))\n    uids = [uids];\n  validateUIDList(uids);\n\n  if (uids.length === 0) {\n    throw new Error('Empty '\n                    + (which === '' ? 'sequence number' : 'uid')\n                    + 'list');\n  }\n\n  uids = uids.join(',');\n\n  var cmd = which + 'FETCH ' + uids + ' (',\n      fetching = [],\n      i, len, key;\n\n  if (this.serverSupports('X-GM-EXT-1')) {\n    fetching.push('X-GM-THRID');\n    fetching.push('X-GM-MSGID');\n    fetching.push('X-GM-LABELS');\n  }\n  if (this.serverSupports('CONDSTORE') && !this._box.nomodseq)\n    fetching.push('MODSEQ');\n\n  fetching.push('UID');\n  fetching.push('FLAGS');\n  fetching.push('INTERNALDATE');\n\n  var modifiers;\n\n  if (options) {\n    modifiers = options.modifiers;\n    if (options.envelope)\n      fetching.push('ENVELOPE');\n    if (options.struct)\n      fetching.push('BODYSTRUCTURE');\n    if (options.size)\n      fetching.push('RFC822.SIZE');\n    if (Array.isArray(options.extensions)) {\n      options.extensions.forEach(function (extension) {\n        fetching.push(extension.toUpperCase());\n      });\n    }\n    cmd += fetching.join(' ');\n    if (options.bodies !== undefined) {\n      var bodies = options.bodies,\n          prefix = (options.markSeen ? '' : '.PEEK');\n      if (!Array.isArray(bodies))\n        bodies = [bodies];\n      for (i = 0, len = bodies.length; i < len; ++i) {\n        fetching.push(parseExpr(''+bodies[i]));\n        cmd += ' BODY' + prefix + '[' + bodies[i] + ']';\n      }\n    }\n  } else\n    cmd += fetching.join(' ');\n\n  cmd += ')';\n\n  var modkeys = (typeof modifiers === 'object' ? Object.keys(modifiers) : []),\n      modstr = ' (';\n  for (i = 0, len = modkeys.length, key; i < len; ++i) {\n    key = modkeys[i].toUpperCase();\n    if (key === 'CHANGEDSINCE' && this.serverSupports('CONDSTORE')\n        && !this._box.nomodseq)\n      modstr += key + ' ' + modifiers[modkeys[i]] + ' ';\n  }\n  if (modstr.length > 2) {\n    cmd += modstr.substring(0, modstr.length - 1);\n    cmd += ')';\n  }\n\n  this._enqueue(cmd);\n  var req = this._queue[this._queue.length - 1];\n  req.fetchCache = {};\n  req.fetching = fetching;\n  return (req.bodyEmitter = new EventEmitter());\n};\n\n// Extension methods ===========================================================\nConnection.prototype.setLabels = function(uids, labels, cb) {\n  this._storeLabels('UID ', uids, labels, '', cb);\n};\n\nConnection.prototype.addLabels = function(uids, labels, cb) {\n  this._storeLabels('UID ', uids, labels, '+', cb);\n};\n\nConnection.prototype.delLabels = function(uids, labels, cb) {\n  this._storeLabels('UID ', uids, labels, '-', cb);\n};\n\nConnection.prototype._storeLabels = function(which, uids, labels, mode, cb) {\n  if (!this.serverSupports('X-GM-EXT-1'))\n    throw new Error('Server must support X-GM-EXT-1 capability');\n  else if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n  else if (uids === undefined)\n    throw new Error('No messages specified');\n\n  if (!Array.isArray(uids))\n    uids = [uids];\n  validateUIDList(uids);\n\n  if (uids.length === 0) {\n    throw new Error('Empty '\n                    + (which === '' ? 'sequence number' : 'uid')\n                    + 'list');\n  }\n\n  if ((!Array.isArray(labels) && typeof labels !== 'string')\n      || (Array.isArray(labels) && labels.length === 0))\n    throw new Error('labels argument must be a string or a non-empty Array');\n\n  if (!Array.isArray(labels))\n    labels = [labels];\n  labels = labels.map(function(v) {\n    return '\"' + escape(utf7.encode(''+v)) + '\"';\n  }).join(' ');\n\n  uids = uids.join(',');\n\n  this._enqueue(which + 'STORE ' + uids + ' ' + mode\n                + 'X-GM-LABELS.SILENT (' + labels + ')', cb);\n};\n\nConnection.prototype.sort = function(sorts, criteria, cb) {\n  this._sort('UID ', sorts, criteria, cb);\n};\n\nConnection.prototype._sort = function(which, sorts, criteria, cb) {\n  if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n  else if (!Array.isArray(sorts) || !sorts.length)\n    throw new Error('Expected array with at least one sort criteria');\n  else if (!Array.isArray(criteria))\n    throw new Error('Expected array for search criteria');\n  else if (!this.serverSupports('SORT'))\n    throw new Error('Sort is not supported on the server');\n\n  sorts = sorts.map(function(c) {\n    if (typeof c !== 'string')\n      throw new Error('Unexpected sort criteria data type. '\n                      + 'Expected string. Got: ' + typeof criteria);\n\n    var modifier = '';\n    if (c[0] === '-') {\n      modifier = 'REVERSE ';\n      c = c.substring(1);\n    }\n    switch (c.toUpperCase()) {\n      case 'ARRIVAL':\n      case 'CC':\n      case 'DATE':\n      case 'FROM':\n      case 'SIZE':\n      case 'SUBJECT':\n      case 'TO':\n        break;\n      default:\n        throw new Error('Unexpected sort criteria: ' + c);\n    }\n\n    return modifier + c;\n  });\n\n  sorts = sorts.join(' ');\n\n  var info = { hasUTF8: false /*output*/ },\n      query = buildSearchQuery(criteria, this._caps, info),\n      charset = 'US-ASCII',\n      lines;\n  if (info.hasUTF8) {\n    charset = 'UTF-8';\n    lines = query.split(CRLF);\n    query = lines.shift();\n  }\n\n  this._enqueue(which + 'SORT (' + sorts + ') ' + charset + query, cb);\n  if (info.hasUTF8) {\n    var req = this._queue[this._queue.length - 1];\n    req.lines = lines;\n  }\n};\n\nConnection.prototype.esearch = function(criteria, options, cb) {\n  this._esearch('UID ', criteria, options, cb);\n};\n\nConnection.prototype._esearch = function(which, criteria, options, cb) {\n  if (this._box === undefined)\n    throw new Error('No mailbox is currently selected');\n  else if (!Array.isArray(criteria))\n    throw new Error('Expected array for search options');\n\n  var info = { hasUTF8: false /*output*/ },\n      query = buildSearchQuery(criteria, this._caps, info),\n      charset = '',\n      lines;\n  if (info.hasUTF8) {\n    charset = ' CHARSET UTF-8';\n    lines = query.split(CRLF);\n    query = lines.shift();\n  }\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = '';\n  } else if (!options)\n    options = '';\n\n  if (Array.isArray(options))\n    options = options.join(' ');\n\n  this._enqueue(which + 'SEARCH RETURN (' + options + ')' + charset + query, cb);\n  if (info.hasUTF8) {\n    var req = this._queue[this._queue.length - 1];\n    req.lines = lines;\n  }\n};\n\nConnection.prototype.setQuota = function(quotaRoot, limits, cb) {\n  if (typeof limits === 'function') {\n    cb = limits;\n    limits = {};\n  }\n\n  var triplets = '';\n  for (var l in limits) {\n    if (triplets)\n      triplets += ' ';\n    triplets += l + ' ' + limits[l];\n  }\n\n  quotaRoot = escape(utf7.encode(''+quotaRoot));\n\n  this._enqueue('SETQUOTA \"' + quotaRoot + '\" (' + triplets + ')',\n    function(err, quotalist) {\n      if (err)\n        return cb(err);\n\n      cb(err, quotalist ? quotalist[0] : limits);\n    }\n  );\n};\n\nConnection.prototype.getQuota = function(quotaRoot, cb) {\n  quotaRoot = escape(utf7.encode(''+quotaRoot));\n\n  this._enqueue('GETQUOTA \"' + quotaRoot + '\"', function(err, quotalist) {\n    if (err)\n      return cb(err);\n\n    cb(err, quotalist[0]);\n  });\n};\n\nConnection.prototype.getQuotaRoot = function(boxName, cb) {\n  boxName = escape(utf7.encode(''+boxName));\n\n  this._enqueue('GETQUOTAROOT \"' + boxName + '\"', function(err, quotalist) {\n    if (err)\n      return cb(err);\n\n    var quotas = {};\n    if (quotalist) {\n      for (var i = 0, len = quotalist.length; i < len; ++i)\n        quotas[quotalist[i].root] = quotalist[i].resources;\n    }\n\n    cb(err, quotas);\n  });\n};\n\nConnection.prototype.thread = function(algorithm, criteria, cb) {\n  this._thread('UID ', algorithm, criteria, cb);\n};\n\nConnection.prototype._thread = function(which, algorithm, criteria, cb) {\n  algorithm = algorithm.toUpperCase();\n\n  if (!this.serverSupports('THREAD=' + algorithm))\n    throw new Error('Server does not support that threading algorithm');\n\n  var info = { hasUTF8: false /*output*/ },\n      query = buildSearchQuery(criteria, this._caps, info),\n      charset = 'US-ASCII',\n      lines;\n  if (info.hasUTF8) {\n    charset = 'UTF-8';\n    lines = query.split(CRLF);\n    query = lines.shift();\n  }\n\n  this._enqueue(which + 'THREAD ' + algorithm + ' ' + charset + query, cb);\n  if (info.hasUTF8) {\n    var req = this._queue[this._queue.length - 1];\n    req.lines = lines;\n  }\n};\n\nConnection.prototype.addFlagsSince = function(uids, flags, modseq, cb) {\n  this._store('UID ',\n              uids,\n              { mode: '+', flags: flags, modseq: modseq },\n              cb);\n};\n\nConnection.prototype.delFlagsSince = function(uids, flags, modseq, cb) {\n  this._store('UID ',\n              uids,\n              { mode: '-', flags: flags, modseq: modseq },\n              cb);\n};\n\nConnection.prototype.setFlagsSince = function(uids, flags, modseq, cb) {\n  this._store('UID ',\n              uids,\n              { mode: '', flags: flags, modseq: modseq },\n              cb);\n};\n\nConnection.prototype.addKeywordsSince = function(uids, keywords, modseq, cb) {\n  this._store('UID ',\n              uids,\n              { mode: '+', keywords: keywords, modseq: modseq },\n              cb);\n};\n\nConnection.prototype.delKeywordsSince = function(uids, keywords, modseq, cb) {\n  this._store('UID ',\n              uids,\n              { mode: '-', keywords: keywords, modseq: modseq },\n              cb);\n};\n\nConnection.prototype.setKeywordsSince = function(uids, keywords, modseq, cb) {\n  this._store('UID ',\n              uids,\n              { mode: '', keywords: keywords, modseq: modseq },\n              cb);\n};\n// END Extension methods =======================================================\n\n// Namespace for seqno-based commands\nObject.defineProperty(Connection.prototype, 'seq', { get: function() {\n  var self = this;\n  return {\n    delKeywords: function(seqnos, keywords, cb) {\n      self._store('', seqnos, { mode: '-', keywords: keywords }, cb);\n    },\n    addKeywords: function(seqnos, keywords, cb) {\n      self._store('', seqnos, { mode: '+', keywords: keywords }, cb);\n    },\n    setKeywords: function(seqnos, keywords, cb) {\n      self._store('', seqnos, { mode: '', keywords: keywords }, cb);\n    },\n\n    delFlags: function(seqnos, flags, cb) {\n      self._store('', seqnos, { mode: '-', flags: flags }, cb);\n    },\n    addFlags: function(seqnos, flags, cb) {\n      self._store('', seqnos, { mode: '+', flags: flags }, cb);\n    },\n    setFlags: function(seqnos, flags, cb) {\n      self._store('', seqnos, { mode: '', flags: flags }, cb);\n    },\n\n    move: function(seqnos, boxTo, cb) {\n      self._move('', seqnos, boxTo, cb);\n    },\n    copy: function(seqnos, boxTo, cb) {\n      self._copy('', seqnos, boxTo, cb);\n    },\n    fetch: function(seqnos, options) {\n      return self._fetch('', seqnos, options);\n    },\n    search: function(options, cb) {\n      self._search('', options, cb);\n    },\n\n    // Extensions ==============================================================\n    delLabels: function(seqnos, labels, cb) {\n      self._storeLabels('', seqnos, labels, '-', cb);\n    },\n    addLabels: function(seqnos, labels, cb) {\n      self._storeLabels('', seqnos, labels, '+', cb);\n    },\n    setLabels: function(seqnos, labels, cb) {\n      self._storeLabels('', seqnos, labels, '', cb);\n    },\n\n    esearch: function(criteria, options, cb) {\n      self._esearch('', criteria, options, cb);\n    },\n\n    sort: function(sorts, options, cb) {\n      self._sort('', sorts, options, cb);\n    },\n    thread: function(algorithm, criteria, cb) {\n      self._thread('', algorithm, criteria, cb);\n    },\n\n    delKeywordsSince: function(seqnos, keywords, modseq, cb) {\n      self._store('',\n                  seqnos,\n                  { mode: '-', keywords: keywords, modseq: modseq },\n                  cb);\n    },\n    addKeywordsSince: function(seqnos, keywords, modseq, cb) {\n      self._store('',\n                  seqnos,\n                  { mode: '+', keywords: keywords, modseq: modseq },\n                  cb);\n    },\n    setKeywordsSince: function(seqnos, keywords, modseq, cb) {\n      self._store('',\n                  seqnos,\n                  { mode: '', keywords: keywords, modseq: modseq },\n                  cb);\n    },\n\n    delFlagsSince: function(seqnos, flags, modseq, cb) {\n      self._store('',\n                  seqnos,\n                  { mode: '-', flags: flags, modseq: modseq },\n                  cb);\n    },\n    addFlagsSince: function(seqnos, flags, modseq, cb) {\n      self._store('',\n                  seqnos,\n                  { mode: '+', flags: flags, modseq: modseq },\n                  cb);\n    },\n    setFlagsSince: function(seqnos, flags, modseq, cb) {\n      self._store('',\n                  seqnos,\n                  { mode: '', flags: flags, modseq: modseq },\n                  cb);\n    }\n  };\n}});\n\nConnection.prototype._resUntagged = function(info) {\n  var type = info.type, i, len, box, attrs, key;\n\n  if (type === 'bye')\n    this._sock.end();\n  else if (type === 'namespace')\n    this.namespaces = info.text;\n  else if (type === 'id')\n    this._curReq.cbargs.push(info.text);\n  else if (type === 'capability')\n    this._caps = info.text.map(function(v) { return v.toUpperCase(); });\n  else if (type === 'preauth')\n    this.state = 'authenticated';\n  else if (type === 'sort' || type === 'thread' || type === 'esearch')\n    this._curReq.cbargs.push(info.text);\n  else if (type === 'search') {\n    if (info.text.results !== undefined) {\n      // CONDSTORE-modified search results\n      this._curReq.cbargs.push(info.text.results);\n      this._curReq.cbargs.push(info.text.modseq);\n    } else\n      this._curReq.cbargs.push(info.text);\n  } else if (type === 'quota') {\n    var cbargs = this._curReq.cbargs;\n    if (!cbargs.length)\n      cbargs.push([]);\n    cbargs[0].push(info.text);\n  } else if (type === 'recent') {\n    if (!this._box && RE_OPENBOX.test(this._curReq.type))\n      this._createCurrentBox();\n    if (this._box)\n      this._box.messages.new = info.num;\n  } else if (type === 'flags') {\n    if (!this._box && RE_OPENBOX.test(this._curReq.type))\n      this._createCurrentBox();\n    if (this._box)\n      this._box.flags = info.text;\n  } else if (type === 'bad' || type === 'no') {\n    if (this.state === 'connected' && !this._curReq) {\n      clearTimeout(this._tmrConn);\n      clearTimeout(this._tmrAuth);\n      var err = new Error('Received negative welcome: ' + info.text);\n      err.source = 'protocol';\n      this.emit('error', err);\n      this._sock.end();\n    }\n  } else if (type === 'exists') {\n    if (!this._box && RE_OPENBOX.test(this._curReq.type))\n      this._createCurrentBox();\n    if (this._box) {\n      var prev = this._box.messages.total,\n          now = info.num;\n      this._box.messages.total = now;\n      if (now > prev && this.state === 'authenticated') {\n        this._box.messages.new = now - prev;\n        this.emit('mail', this._box.messages.new);\n      }\n    }\n  } else if (type === 'expunge') {\n    if (this._box) {\n      if (this._box.messages.total > 0)\n        --this._box.messages.total;\n      this.emit('expunge', info.num);\n    }\n  } else if (type === 'ok') {\n    if (this.state === 'connected' && !this._curReq)\n      this._login();\n    else if (typeof info.textCode === 'string'\n             && info.textCode.toUpperCase() === 'ALERT')\n      this.emit('alert', info.text);\n    else if (this._curReq\n             && info.textCode\n             && (RE_OPENBOX.test(this._curReq.type))) {\n      // we're opening a mailbox\n\n      if (!this._box)\n        this._createCurrentBox();\n\n      if (info.textCode.key)\n        key = info.textCode.key.toUpperCase();\n      else\n        key = info.textCode;\n\n      if (key === 'UIDVALIDITY')\n        this._box.uidvalidity = info.textCode.val;\n      else if (key === 'UIDNEXT')\n        this._box.uidnext = info.textCode.val;\n      else if (key === 'HIGHESTMODSEQ')\n        this._box.highestmodseq = ''+info.textCode.val;\n      else if (key === 'PERMANENTFLAGS') {\n        var idx, permFlags, keywords;\n        this._box.permFlags = permFlags = info.textCode.val;\n        if ((idx = this._box.permFlags.indexOf('\\\\*')) > -1) {\n          this._box.newKeywords = true;\n          permFlags.splice(idx, 1);\n        }\n        this._box.keywords = keywords = permFlags.filter(function(f) {\n                                          return (f[0] !== '\\\\');\n                                        });\n        for (i = 0, len = keywords.length; i < len; ++i)\n          permFlags.splice(permFlags.indexOf(keywords[i]), 1);\n      } else if (key === 'UIDNOTSTICKY')\n        this._box.persistentUIDs = false;\n      else if (key === 'NOMODSEQ')\n        this._box.nomodseq = true;\n    } else if (typeof info.textCode === 'string'\n               && info.textCode.toUpperCase() === 'UIDVALIDITY')\n      this.emit('uidvalidity', info.text);\n  } else if (type === 'list' || type === 'lsub' || type === 'xlist') {\n    if (this.delimiter === undefined)\n      this.delimiter = info.text.delimiter;\n    else {\n      if (this._curReq.cbargs.length === 0)\n        this._curReq.cbargs.push({});\n\n      box = {\n        attribs: info.text.flags,\n        delimiter: info.text.delimiter,\n        children: null,\n        parent: null\n      };\n\n      for (i = 0, len = SPECIAL_USE_ATTRIBUTES.length; i < len; ++i)\n        if (box.attribs.indexOf(SPECIAL_USE_ATTRIBUTES[i]) > -1)\n          box.special_use_attrib = SPECIAL_USE_ATTRIBUTES[i];\n\n      var name = info.text.name,\n          curChildren = this._curReq.cbargs[0];\n\n      if (box.delimiter) {\n        var path = name.split(box.delimiter),\n            parent = null;\n        name = path.pop();\n        for (i = 0, len = path.length; i < len; ++i) {\n          if (!curChildren[path[i]])\n            curChildren[path[i]] = {};\n          if (!curChildren[path[i]].children)\n            curChildren[path[i]].children = {};\n          parent = curChildren[path[i]];\n          curChildren = curChildren[path[i]].children;\n        }\n        box.parent = parent;\n      }\n      if (curChildren[name])\n        box.children = curChildren[name].children;\n      curChildren[name] = box;\n    }\n  } else if (type === 'status') {\n    box = {\n      name: info.text.name,\n      uidnext: 0,\n      uidvalidity: 0,\n      messages: {\n        total: 0,\n        new: 0,\n        unseen: 0\n      }\n    };\n    attrs = info.text.attrs;\n\n    if (attrs) {\n      if (attrs.recent !== undefined)\n        box.messages.new = attrs.recent;\n      if (attrs.unseen !== undefined)\n        box.messages.unseen = attrs.unseen;\n      if (attrs.messages !== undefined)\n        box.messages.total = attrs.messages;\n      if (attrs.uidnext !== undefined)\n        box.uidnext = attrs.uidnext;\n      if (attrs.uidvalidity !== undefined)\n        box.uidvalidity = attrs.uidvalidity;\n      if (attrs.highestmodseq !== undefined) // CONDSTORE\n        box.highestmodseq = ''+attrs.highestmodseq;\n    }\n    this._curReq.cbargs.push(box);\n   } else if (type === 'fetch') {\n    if (/^(?:UID )?FETCH/.test(this._curReq.fullcmd)) {\n      // FETCH response sent as result of FETCH request\n      var msg = this._curReq.fetchCache[info.num],\n          keys = Object.keys(info.text),\n          keyslen = keys.length,\n          toget, msgEmitter, j;\n\n      if (msg === undefined) {\n        // simple case -- no bodies were streamed\n        toget = this._curReq.fetching.slice(0);\n        if (toget.length === 0)\n          return;\n\n        msgEmitter = new EventEmitter();\n        attrs = {};\n\n        this._curReq.bodyEmitter.emit('message', msgEmitter, info.num);\n      } else {\n        toget = msg.toget;\n        msgEmitter = msg.msgEmitter;\n        attrs = msg.attrs;\n      }\n\n      i = toget.length;\n      if (i === 0) {\n        if (msg && !msg.ended) {\n          msg.ended = true;\n          process.nextTick(function() {\n            msgEmitter.emit('end');\n          });\n        }\n        return;\n      }\n\n      if (keyslen > 0) {\n        while (--i >= 0) {\n          j = keyslen;\n          while (--j >= 0) {\n            if (keys[j].toUpperCase() === toget[i]) {\n              if (!RE_BODYPART.test(toget[i])) {\n                if (toget[i] === 'X-GM-LABELS') {\n                  var labels = info.text[keys[j]];\n                  for (var k = 0, lenk = labels.length; k < lenk; ++k)\n                    labels[k] = (''+labels[k]).replace(RE_ESCAPE, '\\\\');\n                }\n                key = FETCH_ATTR_MAP[toget[i]];\n                if (!key)\n                  key = toget[i].toLowerCase();\n                attrs[key] = info.text[keys[j]];\n              }\n              toget.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      if (toget.length === 0) {\n        if (msg)\n          msg.ended = true;\n        process.nextTick(function() {\n          msgEmitter.emit('attributes', attrs);\n          msgEmitter.emit('end');\n        });\n      } else if (msg === undefined) {\n        this._curReq.fetchCache[info.num] = {\n          msgEmitter: msgEmitter,\n          toget: toget,\n          attrs: attrs,\n          ended: false\n        };\n      }\n    } else {\n      // FETCH response sent as result of STORE request or sent unilaterally,\n      // treat them as the same for now for simplicity\n      this.emit('update', info.num, info.text);\n    }\n  }\n};\n\nConnection.prototype._resTagged = function(info) {\n  var req = this._curReq, err;\n\n  if (!req)\n    return;\n\n  this._curReq = undefined;\n\n  if (info.type === 'no' || info.type === 'bad') {\n    var errtext;\n    if (info.text)\n      errtext = info.text;\n    else\n      errtext = req.oauthError;\n    err = new Error(errtext);\n    err.type = info.type;\n    err.textCode = info.textCode;\n    err.source = 'protocol';\n  } else if (this._box) {\n    if (req.type === 'EXAMINE' || req.type === 'SELECT') {\n      this._box.readOnly = (typeof info.textCode === 'string'\n                            && info.textCode.toUpperCase() === 'READ-ONLY');\n    }\n\n    // According to RFC 3501, UID commands do not give errors for\n    // non-existant user-supplied UIDs, so give the callback empty results\n    // if we unexpectedly received no untagged responses.\n    if (RE_UIDCMD_HASRESULTS.test(req.fullcmd) && req.cbargs.length === 0)\n      req.cbargs.push([]);\n  }\n\n  if (req.bodyEmitter) {\n    var bodyEmitter = req.bodyEmitter;\n    if (err)\n      bodyEmitter.emit('error', err);\n    process.nextTick(function() {\n      bodyEmitter.emit('end');\n    });\n  } else {\n    req.cbargs.unshift(err);\n    if (info.textCode && info.textCode.key) {\n      var key = info.textCode.key.toUpperCase();\n      if (key === 'APPENDUID') // [uidvalidity, newUID]\n        req.cbargs.push(info.textCode.val[1]);\n      else if (key === 'COPYUID') // [uidvalidity, sourceUIDs, destUIDs]\n        req.cbargs.push(info.textCode.val[2]);\n    }\n    req.cb && req.cb.apply(this, req.cbargs);\n  }\n\n  if (this._queue.length === 0\n      && this._config.keepalive\n      && this.state === 'authenticated'\n      && !this._idle.enabled) {\n    this._idle.enabled = true;\n    this._doKeepaliveTimer(true);\n  }\n\n  this._processQueue();\n};\n\nConnection.prototype._createCurrentBox = function() {\n  this._box = {\n    name: '',\n    flags: [],\n    readOnly: false,\n    uidvalidity: 0,\n    uidnext: 0,\n    permFlags: [],\n    keywords: [],\n    newKeywords: false,\n    persistentUIDs: true,\n    nomodseq: false,\n    messages: {\n      total: 0,\n      new: 0\n    }\n  };\n};\n\nConnection.prototype._doKeepaliveTimer = function(immediate) {\n  var self = this,\n      interval = this._config.keepalive.interval || KEEPALIVE_INTERVAL,\n      idleWait = this._config.keepalive.idleInterval || MAX_IDLE_WAIT,\n      forceNoop = this._config.keepalive.forceNoop || false,\n      timerfn = function() {\n        if (self._idle.enabled) {\n          // unlike NOOP, IDLE is only a valid command after authenticating\n          if (!self.serverSupports('IDLE')\n              || self.state !== 'authenticated'\n              || forceNoop)\n            self._enqueue('NOOP', true);\n          else {\n            if (self._idle.started === undefined) {\n              self._idle.started = 0;\n              self._enqueue('IDLE', true);\n            } else if (self._idle.started > 0) {\n              var timeDiff = Date.now() - self._idle.started;\n              if (timeDiff >= idleWait) {\n                self._idle.enabled = false;\n                self.debug && self.debug('=> DONE');\n                self._sock.write('DONE' + CRLF);\n                return;\n              }\n            }\n            self._tmrKeepalive = setTimeout(timerfn, interval);\n          }\n        }\n      };\n\n  if (immediate)\n    timerfn();\n  else\n    this._tmrKeepalive = setTimeout(timerfn, interval);\n};\n\nConnection.prototype._login = function() {\n  var self = this, checkedNS = false;\n\n  var reentry = function(err) {\n    clearTimeout(self._tmrAuth);\n    if (err) {\n      self.emit('error', err);\n      return self._sock.end();\n    }\n\n    // 2. Get the list of available namespaces (RFC2342)\n    if (!checkedNS && self.serverSupports('NAMESPACE')) {\n      checkedNS = true;\n      return self._enqueue('NAMESPACE', reentry);\n    }\n\n    // 3. Get the top-level mailbox hierarchy delimiter used by the server\n    self._enqueue('LIST \"\" \"\"', function() {\n      self.state = 'authenticated';\n      self.emit('ready');\n    });\n  };\n\n  // 1. Get the supported capabilities\n  self._enqueue('CAPABILITY', function() {\n    // No need to attempt the login sequence if we're on a PREAUTH connection.\n    if (self.state === 'connected') {\n      var err,\n          checkCaps = function(error) {\n            if (error) {\n              error.source = 'authentication';\n              return reentry(error);\n            }\n\n            if (self._caps === undefined) {\n              // Fetch server capabilities if they were not automatically\n              // provided after authentication\n              return self._enqueue('CAPABILITY', reentry);\n            } else\n              reentry();\n          };\n\n      if (self.serverSupports('STARTTLS')\n          && (self._config.autotls === 'always'\n              || (self._config.autotls === 'required'\n                  && self.serverSupports('LOGINDISABLED')))) {\n          self._starttls();\n          return;\n      }\n\n      if (self.serverSupports('LOGINDISABLED')) {\n        err = new Error('Logging in is disabled on this server');\n        err.source = 'authentication';\n        return reentry(err);\n      }\n\n      var cmd;\n      if (self.serverSupports('AUTH=XOAUTH') && self._config.xoauth) {\n        self._caps = undefined;\n        cmd = 'AUTHENTICATE XOAUTH';\n        // are there any servers that support XOAUTH/XOAUTH2 and not SASL-IR?\n        //if (self.serverSupports('SASL-IR'))\n          cmd += ' ' + escape(self._config.xoauth);\n        self._enqueue(cmd, checkCaps);\n      } else if (self.serverSupports('AUTH=XOAUTH2') && self._config.xoauth2) {\n        self._caps = undefined;\n        cmd = 'AUTHENTICATE XOAUTH2';\n        //if (self.serverSupports('SASL-IR'))\n          cmd += ' ' + escape(self._config.xoauth2);\n        self._enqueue(cmd, checkCaps);\n      } else if (self._config.user && self._config.password) {\n        self._caps = undefined;\n        self._enqueue('LOGIN \"' + escape(self._config.user) + '\" \"'\n                      + escape(self._config.password) + '\"', checkCaps);\n      } else {\n        err = new Error('No supported authentication method(s) available. '\n                        + 'Unable to login.');\n        err.source = 'authentication';\n        return reentry(err);\n      }\n    } else\n      reentry();\n  });\n};\n\nConnection.prototype._starttls = function() {\n  var self = this;\n  this._enqueue('STARTTLS', function(err) {\n    if (err) {\n      self.emit('error', err);\n      return self._sock.end();\n    }\n\n    self._caps = undefined;\n    self._sock.removeAllListeners('error');\n\n    var tlsOptions = {};\n\n    tlsOptions.host = this._config.host;\n    // Host name may be overridden the tlsOptions\n    for (var k in this._config.tlsOptions)\n      tlsOptions[k] = this._config.tlsOptions[k];\n    tlsOptions.socket = self._sock;\n\n    self._sock = tls.connect(tlsOptions, function() {\n      self._login();\n    });\n\n    self._sock.on('error', self._onError);\n    self._sock.on('timeout', self._onSocketTimeout);\n    self._sock.setTimeout(self._config.socketTimeout);\n\n    self._parser.setStream(self._sock);\n  });\n};\n\nConnection.prototype._processQueue = function() {\n  if (this._curReq || !this._queue.length || !this._sock || !this._sock.writable)\n    return;\n\n  this._curReq = this._queue.shift();\n\n  if (this._tagcount === MAX_INT)\n    this._tagcount = 0;\n\n  var prefix;\n\n  if (this._curReq.type === 'IDLE' || this._curReq.type === 'NOOP')\n    prefix = this._curReq.type;\n  else\n    prefix = 'A' + (this._tagcount++);\n\n  var out = prefix + ' ' + this._curReq.fullcmd;\n  this.debug && this.debug('=> ' + inspect(out));\n  this._sock.write(out + CRLF, 'utf8');\n\n  if (this._curReq.literalAppendData) {\n    // LITERAL+: we are appending a mesage, and not waiting for a reply\n    this._sockWriteAppendData(this._curReq.literalAppendData);\n  }\n};\n\nConnection.prototype._sockWriteAppendData = function(appendData)\n{\n  var val = appendData;\n  if (Buffer.isBuffer(appendData))\n    val = val.toString('utf8');\n\n  this.debug && this.debug('=> ' + inspect(val));\n  this._sock.write(val);\n  this._sock.write(CRLF);\n};\n\nConnection.prototype._enqueue = function(fullcmd, promote, cb) {\n  if (typeof promote === 'function') {\n    cb = promote;\n    promote = false;\n  }\n\n  var info = {\n        type: fullcmd.match(RE_CMD)[1],\n        fullcmd: fullcmd,\n        cb: cb,\n        cbargs: []\n      },\n      self = this;\n\n  if (promote)\n    this._queue.unshift(info);\n  else\n    this._queue.push(info);\n\n  if (!this._curReq\n      && this.state !== 'disconnected'\n      && this.state !== 'upgrading') {\n    // defer until next tick for requests like APPEND and FETCH where access to\n    // the request object is needed immediately after enqueueing\n    process.nextTick(function() { self._processQueue(); });\n  } else if (this._curReq\n             && this._curReq.type === 'IDLE'\n             && this._sock\n             && this._sock.writable\n             && this._idle.enabled) {\n    this._idle.enabled = false;\n    clearTimeout(this._tmrKeepalive);\n    if (this._idle.started > 0) {\n      // we've seen the continuation for our IDLE\n      this.debug && this.debug('=> DONE');\n      this._sock.write('DONE' + CRLF);\n    }\n  }\n};\n\nConnection.parseHeader = parseHeader; // from Parser.js\n\nmodule.exports = Connection;\n\n// utilities -------------------------------------------------------------------\n\nfunction escape(str) {\n  return str.replace(RE_BACKSLASH, '\\\\\\\\').replace(RE_DBLQUOTE, '\\\\\"');\n}\n\nfunction validateUIDList(uids, noThrow) {\n  for (var i = 0, len = uids.length, intval; i < len; ++i) {\n    if (typeof uids[i] === 'string') {\n      if (uids[i] === '*' || uids[i] === '*:*') {\n        if (len > 1)\n          uids = ['*'];\n        break;\n      } else if (RE_NUM_RANGE.test(uids[i]))\n        continue;\n    }\n    intval = parseInt(''+uids[i], 10);\n    if (isNaN(intval)) {\n      var err = new Error('UID/seqno must be an integer, \"*\", or a range: '\n                          + uids[i]);\n      if (noThrow)\n        return err;\n      else\n        throw err;\n    } else if (intval <= 0) {\n      var err = new Error('UID/seqno must be greater than zero');\n      if (noThrow)\n        return err;\n      else\n        throw err;\n    } else if (typeof uids[i] !== 'number') {\n      uids[i] = intval;\n    }\n  }\n}\n\nfunction hasNonASCII(str) {\n  for (var i = 0, len = str.length; i < len; ++i) {\n    if (str.charCodeAt(i) > 0x7F)\n      return true;\n  }\n  return false;\n}\n\nfunction buildString(str) {\n  if (typeof str !== 'string')\n    str = ''+str;\n\n  if (hasNonASCII(str)) {\n    var buf = new Buffer(str, 'utf8');\n    return '{' + buf.length + '}\\r\\n' + buf.toString('binary');\n  } else\n    return '\"' + escape(str) + '\"';\n}\n\nfunction buildSearchQuery(options, extensions, info, isOrChild) {\n  var searchargs = '', err, val;\n  for (var i = 0, len = options.length; i < len; ++i) {\n    var criteria = (isOrChild ? options : options[i]),\n        args = null,\n        modifier = (isOrChild ? '' : ' ');\n    if (typeof criteria === 'string')\n      criteria = criteria.toUpperCase();\n    else if (Array.isArray(criteria)) {\n      if (criteria.length > 1)\n        args = criteria.slice(1);\n      if (criteria.length > 0)\n        criteria = criteria[0].toUpperCase();\n    } else\n      throw new Error('Unexpected search option data type. '\n                      + 'Expected string or array. Got: ' + typeof criteria);\n    if (criteria === 'OR') {\n      if (args.length !== 2)\n        throw new Error('OR must have exactly two arguments');\n      if (isOrChild)\n        searchargs += 'OR (';\n      else\n        searchargs += ' OR (';\n      searchargs += buildSearchQuery(args[0], extensions, info, true);\n      searchargs += ') (';\n      searchargs += buildSearchQuery(args[1], extensions, info, true);\n      searchargs += ')';\n    } else {\n      if (criteria[0] === '!') {\n        modifier += 'NOT ';\n        criteria = criteria.substr(1);\n      }\n      switch(criteria) {\n        // -- Standard criteria --\n        case 'ALL':\n        case 'ANSWERED':\n        case 'DELETED':\n        case 'DRAFT':\n        case 'FLAGGED':\n        case 'NEW':\n        case 'SEEN':\n        case 'RECENT':\n        case 'OLD':\n        case 'UNANSWERED':\n        case 'UNDELETED':\n        case 'UNDRAFT':\n        case 'UNFLAGGED':\n        case 'UNSEEN':\n          searchargs += modifier + criteria;\n        break;\n        case 'BCC':\n        case 'BODY':\n        case 'CC':\n        case 'FROM':\n        case 'SUBJECT':\n        case 'TEXT':\n        case 'TO':\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          val = buildString(args[0]);\n          if (info && val[0] === '{')\n            info.hasUTF8 = true;\n          searchargs += modifier + criteria + ' ' + val;\n        break;\n        case 'BEFORE':\n        case 'ON':\n        case 'SENTBEFORE':\n        case 'SENTON':\n        case 'SENTSINCE':\n        case 'SINCE':\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          else if (!(args[0] instanceof Date)) {\n            if ((args[0] = new Date(args[0])).toString() === 'Invalid Date')\n              throw new Error('Search option argument must be a Date object'\n                              + ' or a parseable date string');\n          }\n          searchargs += modifier + criteria + ' ' + args[0].getDate() + '-'\n                        + MONTHS[args[0].getMonth()] + '-'\n                        + args[0].getFullYear();\n        break;\n        case 'KEYWORD':\n        case 'UNKEYWORD':\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          searchargs += modifier + criteria + ' ' + args[0];\n        break;\n        case 'LARGER':\n        case 'SMALLER':\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          var num = parseInt(args[0], 10);\n          if (isNaN(num))\n            throw new Error('Search option argument must be a number');\n          searchargs += modifier + criteria + ' ' + args[0];\n        break;\n        case 'HEADER':\n          if (!args || args.length !== 2)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          val = buildString(args[1]);\n          if (info && val[0] === '{')\n            info.hasUTF8 = true;\n          searchargs += modifier + criteria + ' \"' + escape(''+args[0])\n                     + '\" ' + val;\n        break;\n        case 'UID':\n          if (!args)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          validateUIDList(args);\n          if (args.length === 0)\n            throw new Error('Empty uid list');\n          searchargs += modifier + criteria + ' ' + args.join(',');\n        break;\n        // Extensions ==========================================================\n        case 'X-GM-MSGID': // Gmail unique message ID\n        case 'X-GM-THRID': // Gmail thread ID\n          if (extensions.indexOf('X-GM-EXT-1') === -1)\n            throw new Error('IMAP extension not available for: ' + criteria);\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          else {\n            val = ''+args[0];\n            if (!(RE_INTEGER.test(args[0])))\n              throw new Error('Invalid value');\n          }\n          searchargs += modifier + criteria + ' ' + val;\n        break;\n        case 'X-GM-RAW': // Gmail search syntax\n          if (extensions.indexOf('X-GM-EXT-1') === -1)\n            throw new Error('IMAP extension not available for: ' + criteria);\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          val = buildString(args[0]);\n          if (info && val[0] === '{')\n            info.hasUTF8 = true;\n          searchargs += modifier + criteria + ' ' + val;\n        break;\n        case 'X-GM-LABELS': // Gmail labels\n          if (extensions.indexOf('X-GM-EXT-1') === -1)\n            throw new Error('IMAP extension not available for: ' + criteria);\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          searchargs += modifier + criteria + ' ' + args[0];\n        break;\n        case 'MODSEQ':\n          if (extensions.indexOf('CONDSTORE') === -1)\n            throw new Error('IMAP extension not available for: ' + criteria);\n          if (!args || args.length !== 1)\n            throw new Error('Incorrect number of arguments for search option: '\n                            + criteria);\n          searchargs += modifier + criteria + ' ' + args[0];\n        break;\n        default:\n          // last hope it's a seqno set\n          // http://tools.ietf.org/html/rfc3501#section-6.4.4\n          var seqnos = (args ? [criteria].concat(args) : [criteria]);\n          if (!validateUIDList(seqnos, true)) {\n            if (seqnos.length === 0)\n              throw new Error('Empty sequence number list');\n            searchargs += modifier + seqnos.join(',');\n          } else\n            throw new Error('Unexpected search option: ' + criteria);\n      }\n    }\n    if (isOrChild)\n      break;\n  }\n  return searchargs;\n}\n\n// Pulled from assert.deepEqual:\nvar pSlice = Array.prototype.slice;\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length !== expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (actual instanceof RegExp && expected instanceof RegExp) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual !== 'object' && typeof expected !== 'object') {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === '[object Arguments]';\n}\nfunction objEquiv(a, b) {\n  var ka, kb, key, i;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    ka = Object.keys(a);\n    kb = Object.keys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-imap/imap/lib/Parser.js":"var EventEmitter = require('events').EventEmitter,\n    ReadableStream = require('stream').Readable\n                     || require('readable-stream').Readable,\n    inherits = require('util').inherits,\n    inspect = require('util').inspect;\n\nvar utf7 = require('utf7').imap,\n    jsencoding; // lazy-loaded\n\nvar CH_LF = 10,\n    LITPLACEHOLDER = String.fromCharCode(0),\n    EMPTY_READCB = function(n) {},\n    RE_INTEGER = /^\\d+$/,\n    RE_PRECEDING = /^(?:\\* |A\\d+ |\\+ ?)/,\n    RE_BODYLITERAL = /BODY\\[(.*)\\] \\{(\\d+)\\}$/i,\n    RE_BODYINLINEKEY = /^BODY\\[(.*)\\]$/i,\n    RE_SEQNO = /^\\* (\\d+)/,\n    RE_LISTCONTENT = /^\\((.*)\\)$/,\n    RE_LITERAL = /\\{(\\d+)\\}$/,\n    RE_UNTAGGED = /^\\* (?:(OK|NO|BAD|BYE|FLAGS|ID|LIST|XLIST|LSUB|SEARCH|STATUS|CAPABILITY|NAMESPACE|PREAUTH|SORT|THREAD|ESEARCH|QUOTA|QUOTAROOT)|(\\d+) (EXPUNGE|FETCH|RECENT|EXISTS))(?:(?: \\[([^\\]]+)\\])?(?: (.+))?)?$/i,\n    RE_TAGGED = /^A(\\d+) (OK|NO|BAD) ?(?:\\[([^\\]]+)\\] )?(.*)$/i,\n    RE_CONTINUE = /^\\+(?: (?:\\[([^\\]]+)\\] )?(.+))?$/i,\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?(.+)?$/,\n    RE_ENCWORD = /=\\?([^?*]*?)(?:\\*.*?)?\\?([qb])\\?(.*?)\\?=/gi,\n    RE_ENCWORD_END = /=\\?([^?*]*?)(?:\\*.*?)?\\?([qb])\\?(.*?)\\?=$/i,\n    RE_ENCWORD_BEGIN = /^[ \\t]=\\?([^?*]*?)(?:\\*.*?)?\\?([qb])\\?(.*?)\\?=/i,\n    RE_QENC = /(?:=([a-fA-F0-9]{2}))|_/g,\n    RE_SEARCH_MODSEQ = /^(.+) \\(MODSEQ (.+?)\\)$/i,\n    RE_LWS_ONLY = /^[ \\t]*$/;\n\nfunction Parser(stream, debug) {\n  if (!(this instanceof Parser))\n    return new Parser(stream, debug);\n\n  EventEmitter.call(this);\n\n  this._stream = undefined;\n  this._body = undefined;\n  this._literallen = 0;\n  this._literals = [];\n  this._buffer = '';\n  this._ignoreReadable = false;\n  this.debug = debug;\n\n  var self = this;\n  this._cbReadable = function() {\n    if (self._ignoreReadable)\n      return;\n    if (self._literallen > 0 && !self._body)\n      self._tryread(self._literallen);\n    else\n      self._tryread();\n  };\n\n  this.setStream(stream);\n\n  process.nextTick(this._cbReadable);\n}\ninherits(Parser, EventEmitter);\n\nParser.prototype.setStream = function(stream) {\n  if (this._stream)\n    this._stream.removeListener('readable', this._cbReadable);\n\n  if (/^v0\\.8\\./.test(process.version)) {\n    this._stream = (new ReadableStream()).wrap(stream);\n\n    // since Readable.wrap() proxies events, we need to remove at least the\n    // proxied 'error' event since this can cause problems and Parser doesn't\n    // care about such events\n    stream._events.error.pop();\n  } else\n    this._stream = stream;\n\n  this._stream.on('readable', this._cbReadable);\n};\n\nParser.prototype._tryread = function(n) {\n  if (this._stream.readable) {\n    var r = this._stream.read(n);\n    r && this._parse(r);\n  }\n};\n\nParser.prototype._parse = function(data) {\n  var i = 0, datalen = data.length, idxlf;\n\n  if (this._literallen > 0) {\n    if (this._body) {\n      var body = this._body;\n      if (datalen >= this._literallen) {\n        var litlen = this._literallen;\n        i = litlen;\n        this._literallen = 0;\n        this._body = undefined;\n        body._read = EMPTY_READCB;\n        if (datalen > litlen)\n          body.push(data.slice(0, litlen));\n        else\n          body.push(data);\n        body.push(null);\n      } else {\n        this._literallen -= datalen;\n        var r = body.push(data);\n        if (!r) {\n          body._read = this._cbReadable;\n          return;\n        }\n        i = datalen;\n      }\n    } else {\n      if (datalen > this._literallen)\n        this._literals.push(data.slice(0, this._literallen));\n      else\n        this._literals.push(data);\n      i = this._literallen;\n      this._literallen = 0;\n    }\n  }\n\n  while (i < datalen) {\n    idxlf = indexOfCh(data, datalen, i, CH_LF);\n    if (idxlf === -1) {\n      this._buffer += data.toString('utf8', i);\n      break;\n    } else {\n      this._buffer += data.toString('utf8', i, idxlf);\n      this._buffer = this._buffer.trim();\n      i = idxlf + 1;\n\n      this.debug && this.debug('<= ' + inspect(this._buffer));\n\n      if (RE_PRECEDING.test(this._buffer)) {\n        var firstChar = this._buffer[0];\n        if (firstChar === '*')\n          this._resUntagged();\n        else if (firstChar === 'A')\n          this._resTagged();\n        else if (firstChar === '+')\n          this._resContinue();\n\n        if (this._literallen > 0 && i < datalen) {\n          this._ignoreReadable = true;\n          // literal data included in this chunk -- put it back onto stream\n          this._stream.unshift(data.slice(i));\n          this._ignoreReadable = false;\n          i = datalen;\n          if (!this._body) {\n            // check if unshifted contents satisfies non-body literal length\n            this._tryread(this._literallen);\n          }\n        }\n      } else {\n        this.emit('other', this._buffer);\n        this._buffer = '';\n      }\n    }\n  }\n\n  if (this._literallen === 0 || this._body)\n    this._tryread();\n};\n\nParser.prototype._resTagged = function() {\n  var m;\n  if (m = RE_LITERAL.exec(this._buffer)) {\n    // non-BODY literal -- buffer it\n    this._buffer = this._buffer.replace(RE_LITERAL, LITPLACEHOLDER);\n    this._literallen = parseInt(m[1], 10);\n  } else if (m = RE_TAGGED.exec(this._buffer)) {\n    this._buffer = '';\n    this._literals = [];\n\n    this.emit('tagged', {\n      type: m[2].toLowerCase(),\n      tagnum: parseInt(m[1], 10),\n      textCode: (m[3] ? parseTextCode(m[3], this._literals) : m[3]),\n      text: m[4]\n    });\n  } else\n    this._buffer = '';\n};\n\nParser.prototype._resUntagged = function() {\n  var m;\n  if (m = RE_BODYLITERAL.exec(this._buffer)) {\n    // BODY literal -- stream it\n    var which = m[1], size = parseInt(m[2], 10);\n    this._literallen = size;\n    this._body = new ReadableStream();\n    this._body._readableState.sync = false;\n    this._body._read = EMPTY_READCB;\n    m = RE_SEQNO.exec(this._buffer);\n    this._buffer = this._buffer.replace(RE_BODYLITERAL, '');\n    this.emit('body', this._body, {\n      seqno: parseInt(m[1], 10),\n      which: which,\n      size: size\n    });\n  } else if (m = RE_LITERAL.exec(this._buffer)) {\n    // non-BODY literal -- buffer it\n    this._buffer = this._buffer.replace(RE_LITERAL, LITPLACEHOLDER);\n    this._literallen = parseInt(m[1], 10);\n  } else if (m = RE_UNTAGGED.exec(this._buffer)) {\n    this._buffer = '';\n    // normal single line response\n\n    // m[1] or m[3] = response type\n    // if m[3] is set, m[2] = sequence number (for FETCH) or count\n    // m[4] = response text code (optional)\n    // m[5] = response text (optional)\n\n    var type, num, textCode, val;\n    if (m[2] !== undefined)\n      num = parseInt(m[2], 10);\n    if (m[4] !== undefined)\n      textCode = parseTextCode(m[4], this._literals);\n\n    type = (m[1] || m[3]).toLowerCase();\n\n    if (type === 'flags'\n        || type === 'search'\n        || type === 'capability'\n        || type === 'sort') {\n      if (m[5]) {\n        if (type === 'search' && RE_SEARCH_MODSEQ.test(m[5])) {\n          // CONDSTORE search response\n          var p = RE_SEARCH_MODSEQ.exec(m[5]);\n          val = {\n            results: p[1].split(' '),\n            modseq: p[2]\n          };\n        } else {\n          if (m[5][0] === '(')\n            val = RE_LISTCONTENT.exec(m[5])[1].split(' ');\n          else\n            val = m[5].split(' ');\n\n          if (type === 'search' || type === 'sort')\n            val = val.map(function(v) { return parseInt(v, 10); });\n        }\n      } else\n        val = [];\n    } else if (type === 'thread') {\n      if (m[5])\n        val = parseExpr(m[5], this._literals);\n      else\n        val = [];\n    } else if (type === 'list' || type === 'lsub' || type === 'xlist')\n      val = parseBoxList(m[5], this._literals);\n    else if (type === 'id')\n      val = parseId(m[5], this._literals);\n    else if (type === 'status')\n      val = parseStatus(m[5], this._literals);\n    else if (type === 'fetch')\n      val = parseFetch.call(this, m[5], this._literals, num);\n    else if (type === 'namespace')\n      val = parseNamespaces(m[5], this._literals);\n    else if (type === 'esearch')\n      val = parseESearch(m[5], this._literals);\n    else if (type === 'quota')\n      val = parseQuota(m[5], this._literals);\n    else if (type === 'quotaroot')\n      val = parseQuotaRoot(m[5], this._literals);\n    else\n      val = m[5];\n\n    this._literals = [];\n\n    this.emit('untagged', {\n      type: type,\n      num: num,\n      textCode: textCode,\n      text: val\n    });\n  } else\n    this._buffer = '';\n};\n\nParser.prototype._resContinue = function() {\n  var m = RE_CONTINUE.exec(this._buffer),\n      textCode,\n      text;\n\n  this._buffer = '';\n\n  if (!m)\n    return;\n\n  text = m[2];\n\n  if (m[1] !== undefined)\n    textCode = parseTextCode(m[1], this._literals);\n\n  this.emit('continue', {\n    textCode: textCode,\n    text: text\n  });\n};\n\nfunction indexOfCh(buffer, len, i, ch) {\n  var r = -1;\n  for (; i < len; ++i) {\n    if (buffer[i] === ch) {\n      r = i;\n      break;\n    }\n  }\n  return r;\n}\n\nfunction parseTextCode(text, literals) {\n  var r = parseExpr(text, literals);\n  if (r.length === 1)\n    return r[0];\n  else\n    return { key: r[0], val: r.length === 2 ? r[1] : r.slice(1) };\n}\n\nfunction parseESearch(text, literals) {\n  var r = parseExpr(text.toUpperCase().replace('UID', ''), literals),\n      attrs = {};\n\n  // RFC4731 unfortunately is lacking on documentation, so we're going to\n  // assume that the response text always begins with (TAG \"A123\") and skip that\n  // part ...\n\n  for (var i = 1, len = r.length, key, val; i < len; i += 2) {\n    key = r[i].toLowerCase();\n    val = r[i + 1];\n    if (key === 'all')\n      val = val.toString().split(',');\n    attrs[key] = val;\n  }\n\n  return attrs;\n}\n\nfunction parseId(text, literals) {\n  var r = parseExpr(text, literals),\n      id = {};\n  if (r[0] === null)\n    return null;\n  for (var i = 0, len = r[0].length; i < len; i += 2)\n    id[r[0][i].toLowerCase()] = r[0][i + 1];\n\n  return id;\n}\n\nfunction parseQuota(text, literals) {\n  var r = parseExpr(text, literals),\n      resources = {};\n\n  for (var i = 0, len = r[1].length; i < len; i += 3) {\n    resources[r[1][i].toLowerCase()] = {\n      usage: r[1][i + 1],\n      limit: r[1][i + 2]\n    };\n  }\n\n  return {\n    root: r[0],\n    resources: resources\n  };\n}\n\nfunction parseQuotaRoot(text, literals) {\n  var r = parseExpr(text, literals);\n\n  return {\n    roots: r.slice(1),\n    mailbox: r[0]\n  };\n}\n\nfunction parseBoxList(text, literals) {\n  var r = parseExpr(text, literals);\n  return {\n    flags: r[0],\n    delimiter: r[1],\n    name: utf7.decode(''+r[2])\n  };\n}\n\nfunction parseNamespaces(text, literals) {\n  var r = parseExpr(text, literals), i, len, j, len2, ns, nsobj, namespaces, n;\n\n  for (n = 0; n < 3; ++n) {\n    if (r[n]) {\n      namespaces = [];\n      for (i = 0, len = r[n].length; i < len; ++i) {\n        ns = r[n][i];\n        nsobj = {\n          prefix: ns[0],\n          delimiter: ns[1],\n          extensions: undefined\n        };\n        if (ns.length > 2)\n          nsobj.extensions = {};\n        for (j = 2, len2 = ns.length; j < len2; j += 2)\n          nsobj.extensions[ns[j]] = ns[j + 1];\n        namespaces.push(nsobj);\n      }\n      r[n] = namespaces;\n    }\n  }\n\n  return {\n    personal: r[0],\n    other: r[1],\n    shared: r[2]\n  };\n}\n\nfunction parseStatus(text, literals) {\n  var r = parseExpr(text, literals), attrs = {};\n  // r[1] is [KEY1, VAL1, KEY2, VAL2, .... KEYn, VALn]\n  for (var i = 0, len = r[1].length; i < len; i += 2)\n    attrs[r[1][i].toLowerCase()] = r[1][i + 1];\n  return {\n    name: utf7.decode(''+r[0]),\n    attrs: attrs\n  };\n}\n\nfunction parseFetch(text, literals, seqno) {\n  var list = parseExpr(text, literals)[0], attrs = {}, m, body;\n  // list is [KEY1, VAL1, KEY2, VAL2, .... KEYn, VALn]\n  for (var i = 0, len = list.length, key, val; i < len; i += 2) {\n    key = list[i].toLowerCase();\n    val = list[i + 1];\n    if (key === 'envelope')\n      val = parseFetchEnvelope(val);\n    else if (key === 'internaldate')\n      val = new Date(val);\n    else if (key === 'modseq') // always a list of one value\n      val = ''+val[0];\n    else if (key === 'body' || key === 'bodystructure')\n      val = parseBodyStructure(val);\n    else if (m = RE_BODYINLINEKEY.exec(list[i])) {\n      // a body was sent as a non-literal\n      val = new Buffer(''+val);\n      body = new ReadableStream();\n      body._readableState.sync = false;\n      body._read = EMPTY_READCB;\n      this.emit('body', body, {\n        seqno: seqno,\n        which: m[1],\n        size: val.length\n      });\n      body.push(val);\n      body.push(null);\n      continue;\n    }\n    attrs[key] = val;\n  }\n  return attrs;\n}\n\nfunction parseBodyStructure(cur, literals, prefix, partID) {\n  var ret = [], i, len;\n  if (prefix === undefined) {\n    var result = (Array.isArray(cur) ? cur : parseExpr(cur, literals));\n    if (result.length)\n      ret = parseBodyStructure(result, literals, '', 1);\n  } else {\n    var part, partLen = cur.length, next;\n    if (Array.isArray(cur[0])) { // multipart\n      next = -1;\n      while (Array.isArray(cur[++next])) {\n        ret.push(parseBodyStructure(cur[next],\n                                    literals,\n                                    prefix + (prefix !== '' ? '.' : '')\n                                           + (partID++).toString(), 1));\n      }\n      part = { type: cur[next++].toLowerCase() };\n      if (partLen > next) {\n        if (Array.isArray(cur[next])) {\n          part.params = {};\n          for (i = 0, len = cur[next].length; i < len; i += 2)\n            part.params[cur[next][i].toLowerCase()] = cur[next][i + 1];\n        } else\n          part.params = cur[next];\n        ++next;\n      }\n    } else { // single part\n      next = 7;\n      if (typeof cur[1] === 'string') {\n        part = {\n          // the path identifier for this part, useful for fetching specific\n          // parts of a message\n          partID: (prefix !== '' ? prefix : '1'),\n\n          // required fields as per RFC 3501 -- null or otherwise\n          type: cur[0].toLowerCase(), subtype: cur[1].toLowerCase(),\n          params: null, id: cur[3], description: cur[4], encoding: cur[5],\n          size: cur[6]\n        };\n      } else {\n        // type information for malformed multipart body\n        part = { type: cur[0] ? cur[0].toLowerCase() : null, params: null };\n        cur.splice(1, 0, null);\n        ++partLen;\n        next = 2;\n      }\n      if (Array.isArray(cur[2])) {\n        part.params = {};\n        for (i = 0, len = cur[2].length; i < len; i += 2)\n          part.params[cur[2][i].toLowerCase()] = cur[2][i + 1];\n        if (cur[1] === null)\n          ++next;\n      }\n      if (part.type === 'message' && part.subtype === 'rfc822') {\n        // envelope\n        if (partLen > next && Array.isArray(cur[next]))\n          part.envelope = parseFetchEnvelope(cur[next]);\n        else\n          part.envelope = null;\n        ++next;\n\n        // body\n        if (partLen > next && Array.isArray(cur[next]))\n          part.body = parseBodyStructure(cur[next], literals, prefix, 1);\n        else\n          part.body = null;\n        ++next;\n      }\n      if ((part.type === 'text'\n           || (part.type === 'message' && part.subtype === 'rfc822'))\n          && partLen > next)\n        part.lines = cur[next++];\n      if (typeof cur[1] === 'string' && partLen > next)\n        part.md5 = cur[next++];\n    }\n    // add any extra fields that may or may not be omitted entirely\n    parseStructExtra(part, partLen, cur, next);\n    ret.unshift(part);\n  }\n  return ret;\n}\n\nfunction parseStructExtra(part, partLen, cur, next) {\n  if (partLen > next) {\n    // disposition\n    // null or a special k/v list with these kinds of values:\n    // e.g.: ['Foo', null]\n    //       ['Foo', ['Bar', 'Baz']]\n    //       ['Foo', ['Bar', 'Baz', 'Bam', 'Pow']]\n    var disposition = { type: null, params: null };\n    if (Array.isArray(cur[next])) {\n      disposition.type = cur[next][0];\n      if (Array.isArray(cur[next][1])) {\n        disposition.params = {};\n        for (var i = 0, len = cur[next][1].length, key; i < len; i += 2) {\n          key = cur[next][1][i].toLowerCase();\n          disposition.params[key] = cur[next][1][i + 1];\n        }\n      }\n    } else if (cur[next] !== null)\n      disposition.type = cur[next];\n\n    if (disposition.type === null)\n      part.disposition = null;\n    else\n      part.disposition = disposition;\n\n    ++next;\n  }\n  if (partLen > next) {\n    // language can be a string or a list of one or more strings, so let's\n    // make this more consistent ...\n    if (cur[next] !== null)\n      part.language = (Array.isArray(cur[next]) ? cur[next] : [cur[next]]);\n    else\n      part.language = null;\n    ++next;\n  }\n  if (partLen > next)\n    part.location = cur[next++];\n  if (partLen > next) {\n    // extension stuff introduced by later RFCs\n    // this can really be any value: a string, number, or (un)nested list\n    // let's not parse it for now ...\n    part.extensions = cur[next];\n  }\n}\n\nfunction parseFetchEnvelope(list) {\n  return {\n    date: new Date(list[0]),\n    subject: decodeWords(list[1]),\n    from: parseEnvelopeAddresses(list[2]),\n    sender: parseEnvelopeAddresses(list[3]),\n    replyTo: parseEnvelopeAddresses(list[4]),\n    to: parseEnvelopeAddresses(list[5]),\n    cc: parseEnvelopeAddresses(list[6]),\n    bcc: parseEnvelopeAddresses(list[7]),\n    inReplyTo: list[8],\n    messageId: list[9]\n  };\n}\n\nfunction parseEnvelopeAddresses(list) {\n  var addresses = null;\n  if (Array.isArray(list)) {\n    addresses = [];\n    var inGroup = false, curGroup;\n    for (var i = 0, len = list.length, addr; i < len; ++i) {\n      addr = list[i];\n      if (addr[2] === null) { // end of group addresses\n        inGroup = false;\n        if (curGroup) {\n          addresses.push(curGroup);\n          curGroup = undefined;\n        }\n      } else if (addr[3] === null) { // start of group addresses\n        inGroup = true;\n        curGroup = {\n          group: addr[2],\n          addresses: []\n        };\n      } else { // regular user address\n        var info = {\n          name: decodeWords(addr[0]),\n          mailbox: addr[2],\n          host: addr[3]\n        };\n        if (inGroup)\n          curGroup.addresses.push(info);\n        else if (!inGroup)\n          addresses.push(info);\n      }\n      list[i] = addr;\n    }\n    if (inGroup) {\n      // no end of group found, assume implicit end\n      addresses.push(curGroup);\n    }\n  }\n  return addresses;\n}\n\nfunction parseExpr(o, literals, result, start, useBrackets) {\n  start = start || 0;\n  var inQuote = false,\n      lastPos = start - 1,\n      isTop = false,\n      isBody = false,\n      escaping = false,\n      val;\n\n  if (useBrackets === undefined)\n    useBrackets = true;\n  if (!result)\n    result = [];\n  if (typeof o === 'string') {\n    o = { str: o };\n    isTop = true;\n  }\n  for (var i = start, len = o.str.length; i < len; ++i) {\n    if (!inQuote) {\n      if (isBody) {\n        if (o.str[i] === ']') {\n          val = convStr(o.str.substring(lastPos + 1, i + 1), literals);\n          result.push(val);\n          lastPos = i;\n          isBody = false;\n        }\n      } else if (o.str[i] === '\"')\n        inQuote = true;\n      else if (o.str[i] === ' '\n               || o.str[i] === ')'\n               || (useBrackets && o.str[i] === ']')) {\n        if (i - (lastPos + 1) > 0) {\n          val = convStr(o.str.substring(lastPos + 1, i), literals);\n          result.push(val);\n        }\n        if ((o.str[i] === ')' || (useBrackets && o.str[i] === ']')) && !isTop)\n          return i;\n        lastPos = i;\n      } else if ((o.str[i] === '(' || (useBrackets && o.str[i] === '['))) {\n        if (o.str[i] === '['\n            && i - 4 >= start\n            && o.str.substring(i - 4, i).toUpperCase() === 'BODY') {\n          isBody = true;\n          lastPos = i - 5;\n        } else {\n          var innerResult = [];\n          i = parseExpr(o, literals, innerResult, i + 1, useBrackets);\n          lastPos = i;\n          result.push(innerResult);\n        }\n      }\n    } else if (o.str[i] === '\\\\')\n      escaping = !escaping;\n    else if (o.str[i] === '\"') {\n      if (!escaping)\n        inQuote = false;\n      escaping = false;\n    }\n    if (i + 1 === len && len - (lastPos + 1) > 0)\n      result.push(convStr(o.str.substring(lastPos + 1), literals));\n  }\n  return (isTop ? result : start);\n}\n\nfunction convStr(str, literals) {\n  if (str[0] === '\"') {\n    str = str.substring(1, str.length - 1);\n    var newstr = '', isEscaping = false, p = 0;\n    for (var i = 0, len = str.length; i < len; ++i) {\n      if (str[i] === '\\\\') {\n        if (!isEscaping)\n          isEscaping = true;\n        else {\n          isEscaping = false;\n          newstr += str.substring(p, i - 1);\n          p = i;\n        }\n      } else if (str[i] === '\"') {\n        if (isEscaping) {\n          isEscaping = false;\n          newstr += str.substring(p, i - 1);\n          p = i;\n        }\n      }\n    }\n    if (p === 0)\n      return str;\n    else {\n      newstr += str.substring(p);\n      return newstr;\n    }\n  } else if (str === 'NIL')\n    return null;\n  else if (RE_INTEGER.test(str)) {\n    // some IMAP extensions utilize large (64-bit) integers, which JavaScript\n    // can't handle natively, so we'll just keep it as a string if it's too big\n    var val = parseInt(str, 10);\n    return (val.toString() === str ? val : str);\n  } else if (literals && literals.length && str === LITPLACEHOLDER) {\n    var l = literals.shift();\n    if (Buffer.isBuffer(l))\n      l = l.toString('utf8');\n    return l;\n  }\n\n  return str;\n}\n\nfunction repeat(chr, len) {\n  var s = '';\n  for (var i = 0; i < len; ++i)\n    s += chr;\n  return s;\n}\n\nfunction decodeBytes(buf, encoding, offset, mlen, pendoffset, state, nextBuf) {\n  if (!jsencoding)\n    jsencoding = require('../deps/encoding/encoding');\n  if (jsencoding.encodingExists(encoding)) {\n    if (state.buffer !== undefined) {\n      if (state.encoding === encoding && state.consecutive) {\n        // concatenate buffer + current bytes in hopes of finally having\n        // something that's decodable\n        var newbuf = new Buffer(state.buffer.length + buf.length);\n        state.buffer.copy(newbuf, 0);\n        buf.copy(newbuf, state.buffer.length);\n        buf = newbuf;\n      } else {\n        // either:\n        //   - the current encoded word is not separated by the previous partial\n        //     encoded word by linear whitespace, OR\n        //   - the current encoded word and the previous partial encoded word\n        //     use different encodings\n        state.buffer = state.encoding = undefined;\n        state.curReplace = undefined;\n      }\n    }\n    var ret, isPartial = false;\n    if (state.remainder !== undefined) {\n      // use cached remainder from the previous lookahead\n      ret = state.remainder;\n      state.remainder = undefined;\n    } else {\n      try {\n        ret = jsencoding.TextDecoder(encoding).decode(buf);\n      } catch (e) {\n        if (e.message.indexOf('Seeking') === 0)\n          isPartial = true;\n      }\n    }\n    if (!isPartial && nextBuf) {\n      // try to decode a lookahead buffer (current buffer + next buffer)\n      // and see if it starts with the decoded value of the current buffer.\n      // if not, the current buffer is partial\n      var lookahead, lookaheadBuf = new Buffer(buf.length + nextBuf.length);\n      buf.copy(lookaheadBuf);\n      nextBuf.copy(lookaheadBuf, buf.length);\n      try {\n        lookahead = jsencoding.TextDecoder(encoding).decode(lookaheadBuf);\n      } catch(e) {\n        // cannot decode the lookahead, do nothing\n      }\n      if (lookahead !== undefined) {\n        if (lookahead.indexOf(ret) === 0) {\n          // the current buffer is whole, cache the lookahead's remainder\n          state.remainder = lookahead.substring(ret.length);\n        } else {\n          isPartial = true;\n          ret = undefined;\n        }\n      }\n    }\n    if (ret !== undefined) {\n      if (state.curReplace) {\n        // we have some previous partials which were finally \"satisfied\" by the\n        // current encoded word, so replace from the beginning of the first\n        // partial to the end of the current encoded word\n        state.replaces.push({\n          fromOffset: state.curReplace[0].fromOffset,\n          toOffset: offset + mlen,\n          val: ret\n        });\n        state.replaces.splice(state.replaces.indexOf(state.curReplace), 1);\n        state.curReplace = undefined;\n      } else {\n        // normal case where there are no previous partials and we successfully\n        // decoded a single encoded word\n        state.replaces.push({\n          // we ignore linear whitespace between consecutive encoded words\n          fromOffset: state.consecutive ? pendoffset : offset,\n          toOffset: offset + mlen,\n          val: ret\n        });\n      }\n      state.buffer = state.encoding = undefined;\n      return;\n    } else if (isPartial) {\n      // RFC2047 says that each decoded encoded word \"MUST represent an integral\n      // number of characters. A multi-octet character may not be split across\n      // adjacent encoded-words.\" However, some MUAs appear to go against this,\n      // so we join broken encoded words separated by linear white space until\n      // we can successfully decode or we see a change in encoding\n      state.encoding = encoding;\n      state.buffer = buf;\n      if (!state.curReplace)\n        state.replaces.push(state.curReplace = []);\n      state.curReplace.push({\n        fromOffset: offset,\n        toOffset: offset + mlen,\n        // the value we replace this encoded word with if it doesn't end up\n        // becoming part of a successful decode\n        val: repeat('\\uFFFD', buf.length)\n      });\n      return;\n    }\n  }\n  // in case of unexpected error or unsupported encoding, just substitute the\n  // raw bytes\n  state.replaces.push({\n    fromOffset: offset,\n    toOffset: offset + mlen,\n    val: buf.toString('binary')\n  });\n}\n\nfunction qEncReplacer(match, byte) {\n  if (match === '_')\n    return ' ';\n  else\n    return String.fromCharCode(parseInt(byte, 16));\n}\nfunction decodeWords(str, state) {\n  var pendoffset = -1;\n\n  if (!state) {\n    state = {\n      buffer: undefined,\n      encoding: undefined,\n      consecutive: false,\n      replaces: undefined,\n      curReplace: undefined,\n      remainder: undefined\n    };\n  }\n\n  state.replaces = [];\n\n  var bytes, m, next, i, j, leni, lenj, seq, replaces = [], lastReplace = {};\n\n  // join consecutive q-encoded words that have the same charset first\n  while (m = RE_ENCWORD.exec(str)) {\n    seq = {\n      consecutive: (pendoffset > -1\n                    ? RE_LWS_ONLY.test(str.substring(pendoffset, m.index))\n                    : false),\n      charset: m[1].toLowerCase(),\n      encoding: m[2].toLowerCase(),\n      chunk: m[3],\n      index: m.index,\n      length: m[0].length,\n      pendoffset: pendoffset,\n      buf: undefined\n    };\n    lastReplace = replaces.length && replaces[replaces.length - 1];\n    if (seq.consecutive\n        && seq.charset === lastReplace.charset\n        && seq.encoding === lastReplace.encoding\n        && seq.encoding === 'q') {\n      lastReplace.length += seq.length + seq.index - pendoffset;\n      lastReplace.chunk += seq.chunk;\n    } else {\n      replaces.push(seq);\n      lastReplace = seq;\n    }\n    pendoffset = m.index + m[0].length;\n  }\n\n  // generate replacement substrings and their positions\n  for (i = 0, leni = replaces.length; i < leni; ++i) {\n    m = replaces[i];\n    state.consecutive = m.consecutive;\n    if (m.encoding === 'q') {\n      // q-encoding, similar to quoted-printable\n      bytes = new Buffer(m.chunk.replace(RE_QENC, qEncReplacer), 'binary');\n      next = undefined;\n    } else {\n      // base64\n      bytes = m.buf || new Buffer(m.chunk, 'base64');\n      next = replaces[i + 1];\n      if (next && next.consecutive && next.encoding === m.encoding\n        && next.charset === m.charset) {\n        // we use the next base64 chunk, if any, to determine the integrity\n        // of the current chunk\n        next.buf = new Buffer(next.chunk, 'base64');\n      }\n    }\n    decodeBytes(bytes, m.charset, m.index, m.length, m.pendoffset, state,\n      next && next.buf);\n  }\n\n  // perform the actual replacements\n  for (i = state.replaces.length - 1; i >= 0; --i) {\n    seq = state.replaces[i];\n    if (Array.isArray(seq)) {\n      for (j = 0, lenj = seq.length; j < lenj; ++j) {\n        str = str.substring(0, seq[j].fromOffset)\n              + seq[j].val\n              + str.substring(seq[j].toOffset);\n      }\n    } else {\n      str = str.substring(0, seq.fromOffset)\n            + seq.val\n            + str.substring(seq.toOffset);\n    }\n  }\n\n  return str;\n}\n\nfunction parseHeader(str, noDecode) {\n  var lines = str.split(RE_CRLF),\n      len = lines.length,\n      header = {},\n      state = {\n        buffer: undefined,\n        encoding: undefined,\n        consecutive: false,\n        replaces: undefined,\n        curReplace: undefined,\n        remainder: undefined\n      },\n      m, h, i, val;\n\n  for (i = 0; i < len; ++i) {\n    if (lines[i].length === 0)\n      break; // empty line separates message's header and body\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      if (!Array.isArray(header[h]))\n        continue; // ignore invalid first line\n      // folded header content\n      val = lines[i];\n      if (!noDecode) {\n        if (RE_ENCWORD_END.test(lines[i - 1])\n            && RE_ENCWORD_BEGIN.test(val)) {\n          // RFC2047 says to *ignore* leading whitespace in folded header values\n          // for adjacent encoded-words ...\n          val = val.substring(1);\n        }\n      }\n      header[h][header[h].length - 1] += val;\n    } else {\n      m = RE_HDR.exec(lines[i]);\n      if (m) {\n        h = m[1].toLowerCase().trim();\n        if (m[2]) {\n          if (header[h] === undefined)\n            header[h] = [m[2]];\n          else\n            header[h].push(m[2]);\n        } else\n          header[h] = [''];\n      } else\n        break;\n    }\n  }\n  if (!noDecode) {\n    var hvs;\n    for (h in header) {\n      hvs = header[h];\n      for (i = 0, len = header[h].length; i < len; ++i)\n        hvs[i] = decodeWords(hvs[i], state);\n    }\n  }\n\n  return header;\n}\n\nexports.Parser = Parser;\nexports.parseExpr = parseExpr;\nexports.parseEnvelopeAddresses = parseEnvelopeAddresses;\nexports.parseBodyStructure = parseBodyStructure;\nexports.parseHeader = parseHeader;\n"}